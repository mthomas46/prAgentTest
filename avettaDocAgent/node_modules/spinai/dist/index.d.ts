import z, { z as z$1 } from 'zod';
import { CoreMessage, LanguageModelV1, LanguageModelUsage } from 'ai';

declare const planningSchema: z.ZodObject<{
    response: z.ZodObject<{
        textResponse: z.ZodString;
        reasoning: z.ZodString;
        parametersReasoning: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        textResponse: string;
        reasoning: string;
        parametersReasoning: string;
    }, {
        textResponse: string;
        reasoning: string;
        parametersReasoning: string;
    }>;
    nextActions: z.ZodDefault<z.ZodArray<z.ZodObject<{
        actionId: z.ZodString;
        parameters: z.ZodDefault<z.ZodRecord<z.ZodString, z.ZodUnknown>>;
    }, "strip", z.ZodTypeAny, {
        actionId: string;
        parameters: Record<string, unknown>;
    }, {
        actionId: string;
        parameters?: Record<string, unknown> | undefined;
    }>, "many">>;
}, "strip", z.ZodTypeAny, {
    response: {
        textResponse: string;
        reasoning: string;
        parametersReasoning: string;
    };
    nextActions: {
        actionId: string;
        parameters: Record<string, unknown>;
    }[];
}, {
    response: {
        textResponse: string;
        reasoning: string;
        parametersReasoning: string;
    };
    nextActions?: {
        actionId: string;
        parameters?: Record<string, unknown> | undefined;
    }[] | undefined;
}>;

/**
 * Gets the current package version
 * @returns The package version string
 */
declare function getPackageVersion(): string;

type TaskLoopParams<TResponseFormat = "text" | z$1.ZodType<any>> = AgentConfig & AgentRunConfig<TResponseFormat>;
interface ExecutedAction {
    id: string;
    parameters?: Record<string, unknown>;
    result?: unknown;
    status: "success" | "error";
    errorMessage?: string;
}
interface RunState {
    input: string;
    [key: string]: unknown;
}

declare function runTaskLoop<TResponseFormat extends "text" | z$1.ZodType<any> = "text", TResponse = InferResponseType<TResponseFormat>>(taskLoopParams: TaskLoopParams<TResponseFormat>): Promise<AgentResponse<TResponse>>;

interface Action {
    id: string;
    description: string;
    parameters?: {
        type: "object";
        properties: Record<string, unknown>;
        required?: string[];
    };
    run: (params: {
        context: TaskLoopParams;
        parameters?: Record<string, unknown>;
    }) => Promise<any>;
    dependsOn?: string[];
    retries?: number;
}

declare function createAction(config: Action): Action;

declare function formatActionForPrompt(action: Action): string;
declare function formatActionsForPrompt(actions: Action[]): string;

type LogLevel = "debug" | "info" | "error";
type DebugMode = "none" | "default" | "verbose" | "all";
type LogType = "llm" | "action" | "response" | "summary";
interface LogOptions {
    level?: "info" | "debug" | "error";
    type?: "llm" | "action" | "summary" | "response" | "action-schedule";
    data?: unknown;
}

declare function setDebugEnabled(mode?: DebugMode): void;
declare function log(message: string, options?: LogOptions): void;

type Messages = CoreMessage[];
type Message = CoreMessage;

/**
 * Creates a system message with instructions and available actions
 * @param instructions The system instructions
 * @param actions The available actions
 * @returns A formatted system message
 */
declare function createSystemMessage(instructions: string, actions: Action[]): Promise<Message>;

/**
 * Creates a text-only assistant message
 * @param textResponse The text response to the user
 * @returns A formatted assistant message with only text content
 */
declare function createAssistantTextMessage(textResponse: string): Promise<Message>;
/**
 * Creates an assistant message with tool calls
 * @param textResponse The text response to the user
 * @param reasoning The reasoning behind the response
 * @param nextActions Array of next actions to execute
 * @returns A formatted assistant message with text, reasoning, and tool calls
 */
declare function createAssistantToolCallsMessage(textResponse: string, reasoning: string, nextActions: Array<{
    actionId: string;
    parameters: Record<string, unknown>;
    toolCallId: string;
}>): Promise<Message>;
/**
 * Creates an assistant message based on the response and nextActions
 * @param textResponse The text response to the user
 * @param reasoning The reasoning behind the response
 * @param nextActions Array of next actions to execute (can be empty)
 * @returns A formatted assistant message
 * @deprecated Use createAssistantTextMessage or createAssistantToolCallsMessage instead
 */
declare function createAssistantMessage(textResponse: string, reasoning: string, nextActions: Array<{
    actionId: string;
    parameters: Record<string, unknown>;
    toolCallId: string;
}>): Promise<Message>;

/**
 * Creates a tool message from an action result
 * @param actionId The ID of the action that was executed
 * @param result The result of the action execution
 * @param toolCallId The ID of the tool call this is responding to
 * @returns A formatted tool message
 */
declare function createActionResultMessage(actionId: string, result: any, toolCallId: string): Promise<Message>;

/**
 * Creates a system message with instructions and available actions
 * @param instructions The system instructions
 * @param actions The available actions
 * @returns A formatted system message
 */
declare function createUserMessage(input: string): Promise<Message>;

interface AgentConfig {
    instructions: string;
    model: LanguageModelV1;
    actions: Action[];
    agentId?: string;
    spinApiKey?: string;
    customLoggingEndpoint?: string;
    fixedSteps?: FixedStep[];
}
interface AgentRunConfig<TResponseFormat = "text" | z$1.ZodType<any>> {
    input: string;
    maxSteps?: number;
    sessionId?: string;
    externalCustomerId?: string;
    state?: Record<string, any>;
    isRerun?: boolean;
    actions?: Action[];
    model?: LanguageModelV1;
    debug?: DebugMode;
    agentId?: string;
    spinApiKey?: string;
    responseFormat?: TResponseFormat;
    customLoggingEndpoint?: string;
    messages?: Messages;
    fixedSteps?: FixedStep[];
}
type FixedStep = {
    actionId: string;
    parameters: Record<string, any>;
};
type InferResponseType<T> = T extends z$1.ZodType<infer U> ? U : T extends "text" ? string : unknown;
interface AgentResponse<T = unknown> {
    response: T;
    sessionId: string;
    interactionId: string;
    totalDurationMs: number;
    totalCostCents: number;
    totalPromptTokens: number;
    totalCompletionTokens: number;
    state: Record<string, unknown>;
    messages: Messages;
}
type Agent<T extends "text" | z$1.ZodType<any> = "text"> = <TResponseFormat extends T | "text" | z$1.ZodType<any> = T>(runConfig: AgentRunConfig<TResponseFormat>) => Promise<AgentResponse<InferResponseType<TResponseFormat>>>;

declare function createAgent<T extends "text" | z$1.ZodType<any> = "text">(config: AgentConfig): Agent<T>;

interface CliChatOptions {
    /**
     * Custom input prompt (the text shown before user input)
     * @default "> "
     */
    inputPrompt?: string;
    /**
     * Command to exit the chat
     * @default "exit"
     */
    exitCommand?: string;
    /**
     * Custom function to format the agent's response
     * @default (response) => console.log(`Assistant: ${response}\n`)
     */
    formatResponse?: (response: string) => void;
    /**
     * Custom error handler
     * @default (error) => console.error("\nError:", error, "\n")
     */
    onError?: (error: unknown) => void;
}
/**
 * Starts a CLI chat session with the provided agent
 * @param agent The SpinAI agent to chat with
 * @param options Configuration options for the CLI chat
 */
declare function startCliChat<T extends "text" | z$1.ZodType<any> = "text">(agent: Agent<T>, options?: CliChatOptions): void;

/**
 * Cost structure for a model (input and output costs per 1M tokens in USD)
 */
interface ModelCost {
    input: number;
    output: number;
}
/**
 * Map of model IDs to their cost structures
 */
type ModelCostsMap = Record<string, ModelCost>;
/**
 * Type for model IDs in the costs map
 */
type ModelId = string;
/**
 * Parameters for the calculateCost function
 */
interface CalculateCostParams {
    usage: any;
    model: string;
}

/**
 * Calculates the cost in USD based on token usage
 * @param params The calculation parameters
 * @returns The cost in USD
 */
declare function calculateCost(params: CalculateCostParams): number;
/**
 * Calculates the cost in cents based on token usage
 * @param usage The token usage from the language model
 * @param modelId The ID of the model used
 * @returns The cost in cents
 */
declare function calculateCostFromUsage(usage: LanguageModelUsage | undefined, modelId: string): number;

/**
 * Combined cost map for all models
 */
declare const MODEL_COSTS: ModelCostsMap;

interface LoggingConfig {
    agentId?: string;
    spinApiKey?: string;
    sessionId: string;
    interactionId: string;
    modelId: string;
    modelProvider?: string;
    externalCustomerId?: string;
    loggingEndpoint?: string;
    isRerun?: boolean;
    input: string;
    initialState?: Record<string, unknown>;
}

/**
 * Core logging service that maps directly to the steps database table
 */
declare class LoggingService {
    private agentId?;
    private spinApiKey?;
    private sessionId;
    private interactionId;
    private modelId;
    private modelProvider;
    private externalCustomerId?;
    private startTime;
    private loggingEndpoint;
    private isRerun;
    private input;
    private initialState?;
    private packageVersion;
    constructor(config: LoggingConfig);
    /**
     * Core method to log a step to the database
     */
    private logStep;
    /**
     * Log the start of an interaction
     */
    logInteractionStart(): Promise<void>;
    /**
     * Log an agent planning step (reasoning and next actions)
     */
    logPlanning(params: {
        reasoning: string;
        textResponse: string;
        nextActions?: any[];
        promptTokens: number;
        completionTokens: number;
        costCents?: number;
        durationMs: number;
        state?: Record<string, unknown>;
        rawInput?: unknown;
        rawOutput?: unknown;
        status: "completed" | "failed";
        error_message?: string;
    }): Promise<void>;
    /**
     * Log an action execution
     */
    logAction(params: {
        actionId: string;
        parameters?: Record<string, unknown>;
        result: unknown;
        durationMs: number;
        state?: Record<string, unknown>;
        error?: Error;
    }): Promise<void>;
    /**
     * Log the final response generation
     */
    logFinalResponse(params: {
        response: unknown;
        usage: {
            promptTokens: number;
            completionTokens: number;
            costCents?: number;
        };
        durationMs: number;
        state?: Record<string, unknown>;
        rawInput?: unknown;
        rawOutput?: unknown;
    }): Promise<void>;
    /**
     * Log the completion of an interaction
     */
    logInteractionComplete(params: {
        response: unknown;
        durationMs?: number;
        error?: Error;
        state?: Record<string, unknown>;
        messages?: unknown[];
        totalCostCents: number;
        totalPromptTokens: number;
        totalCompletionTokens: number;
    }): Promise<void>;
}

interface McpConfig {
    [key: string]: {
        command: string;
        args: string[];
        /**
         * Environment variable mapping for this MCP.
         * Format: { "MCP_VAR_NAME": "value_or_env_var_name" }
         * If the value is an environment variable name, its value will be used.
         * Otherwise, the literal value will be used.
         */
        envMapping?: Record<string, string | undefined>;
    };
}

/**
 * Options for creating actions from MCP config
 */
interface CreateActionsFromMcpConfigOptions {
    /** The MCP configuration object */
    config: McpConfig;
    /**
     * Environment variable mappings to apply to all MCPs.
     * Format: { "MCP_VAR_NAME": "value_or_env_var_name" }
     * If the value is an environment variable name, its value will be used.
     * Otherwise, the literal value will be used.
     */
    envMapping?: Record<string, string | undefined>;
    /** IDs of actions to exclude */
    excludedActions?: string[];
    /** IDs of actions to include (if empty, all actions except excluded ones are included) */
    includedActions?: string[];
}
/**
 * Creates SpinAI actions from an MCP configuration
 */
declare function createActionsFromMcpConfig({ config, envMapping: globalEnvMapping, excludedActions, includedActions, }: CreateActionsFromMcpConfigOptions): Promise<Action[]>;

export { type Action, type Agent, type AgentConfig, type AgentResponse, type AgentRunConfig, type CalculateCostParams, type CreateActionsFromMcpConfigOptions, type DebugMode, type ExecutedAction, type FixedStep, type InferResponseType, type LogLevel, type LogOptions, type LogType, type LoggingConfig, LoggingService, MODEL_COSTS, type McpConfig, type Message, type Messages, type ModelCost, type ModelCostsMap, type ModelId, type RunState, type TaskLoopParams, calculateCost, calculateCostFromUsage, createAction, createActionResultMessage, createActionsFromMcpConfig, createAgent, createAssistantMessage, createAssistantTextMessage, createAssistantToolCallsMessage, createSystemMessage, createUserMessage, formatActionForPrompt, formatActionsForPrompt, getPackageVersion, log, planningSchema, runTaskLoop, setDebugEnabled, startCliChat };
